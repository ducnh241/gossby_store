<?php

/**
 * OSECORE
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the GNU General Public License version 3
 * that is bundled with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.gnu.org/licenses/gpl-3.0.html
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@osecore.com so we can send you a copy immediately.
 *
 * DISCLAIMER
 *
 * Do not edit or add to this file if you wish to upgrade OSECORE to newer
 * versions in the future. If you wish to customize OSECORE for your
 * needs please refer to http://www.osecore.com for more information.
 *
 * @copyright	Copyright (C) 2014 by Sang Le Tuan (http://www.osecore.com). All rights reserved.
 * @license     http://www.gnu.org/licenses/gpl-3.0.html GNU General Public License version 3
 * @author      Sang Le Tuan - batsatla@gmail.com
 */
class OSC_Cron_Controller_Callback extends OSC_Controller {

    const TRIGGER_CLI = true;
    protected $_CRON_LIST = [
//        'developer/migrateOptionsDesignOrder',
//        'developer/convertCrossSell_cart',
//        'developer/convertCrossSell_order',
//        'developer/convertDoormat_cart',
//        'developer/convertDoormat_order',
//        'developer/genDiscountcodeGift ',
        'core/estimateTimeRunCron',
        'core/generateSitemap',
//        'core/imageOptimize',
        'storage_cleanTmp',
        'core/generateRobotTxt',
        'postOffice/email_marketing_make',
        'postOffice/email_marketing',
        'catalog/campaign_updateReorderVariants',
        'catalog/campaign_createMockupCampaign',
        'catalog/campaign_renderMockup',
        'catalog/campaign_createMockupCampaignTool',
        'catalog/campaign_renderMockupTool',
        'catalog/product_getCurrencyRate',
        'catalog/product_bulkDiscard',
        'catalog/product_bulkActive',
        'catalog/product_bulk_delete',
        'catalog/product_bulk_importDataSEO',
        'catalog/collection_bulk_importDataSEO',
        'catalog/product_bulkSetListing',
        'catalog/product_autoListingDiscard',
        'catalog/product_correctCollectionIds',
        'catalog/campaign_deleteRenderMockup',
        'catalog/recheckTransaction',
        'catalog/discountCode_cleanAutoGenerated',
        'catalog/upsale_updateBillingAgreementToken',
        'catalog/campaign_updateImageVariant',
        'feed/review',
        'feed/klaviyo_newArrival',
        'catalog/product_seedingProductPrice',
        'catalog/product_updateBetaOrder',
        'personalizedDesign/sync',
        'personalizedDesign/analyticProcessQueue',
        'personalizedDesign/reRenderOrderByDesign',
        'personalizedDesign/deleteReRenderLog',
        'personalizedDesign/convert',
        'personalizedDesign/import',
//        'personalizedDesign/checkPersonalizedOverflow',
        'catalog/collection_resetCacheProductQueue',
        'catalog/collection_genProductByRelativeRange',
        'masterSync/sync',
        'klaviyo/abandoned',
        'klaviyo/push',
        'klaviyo/feed',
        'smsMarketing/klaviyoPush',
        'smsMarketing/abandoned',
//        'smsMarketing/sendSMSCampaign',
//        'facebook/executeSetEvent',
//        'developer/convertProductVariant',
//        'developer/migrateProduct',
//        'developer/convertStructureUrl',
//        'smsMarketing/exportPhoneNumber',
        'supplier/renderSupplyVariant',
        'catalog/cache',
//        'developer/convertOrderItemMeta',
        'catalog/order_afterOrderCreated',
        'catalog/order_sendMailReview',
        'catalog/campaign_rerenderDesignV2',
        'catalog/campaign_renderDesignOrderBeta',
//        'developer/exportDataByCEO',
//        'catalog/insertCollectionProductRel',
        'catalog/campaign_setPriceAutoAbTest',
//        'personalizedDesign/convertPaletteColor',
        'post/rss',
        'core/pushNotify',
//        'crossSell/updateImageVariantCrossSell',
//        'crossSell/pushMockup',
//        'crossSell/createCampaignMockupCrossSell',
        'report/insertAdTracking',
        'catalog/campaign_rerenderDesignUrl',
        'personalizedDesign/duplicateDesignToD3',
        'personalizedDesign/duplicateDesignToDe',
        'catalog/order_analytic',
        'personalizedDesign/renderDesignSvgBeta',
        'personalizedDesign/uploadToS3',
        'account/updateCrmAfterPlaceOrder',
        'catalog/order_syncAirTable',
        'filter/setting',
        'filter/settingFilterCollection',
        'filter/exportKeyword',
        'filter/importTag',
        'filter/autoTag',
        //'catalog/cart_backup',
        'd2/scanAirtableDesign',
        'd2/syncDesign',
        'd2/syncAirtableOrderResend',
        'd2/updateAirtable',
        'd2/syncDesign',
        'd2/afterProductCreated',
        'd2/flows',
        'd2/syncFlowReply',
        'd2/retrySyncFlowReply',
        'd2/updateRawAirtable',
        'personalizedDesign/scanTools',
        'catalog/order_renderDesignAfterOrderCreated',
        'developer/convertHeartPlaqueCart',
        'developer/convertHeartPlaqueProduct',
        'catalog/product_bulkUploadProduct',
        'catalog/algolia_syncProduct',
        'marketing/updateOldOrderPoint',
        'catalog/algolia_partiaUpdate'
    ];

    public function __construct() {
        parent::__construct();

        set_time_limit(0);
        ini_set('memory_limit', '2000M');
    }

    protected function _scanAndMakeCrontab($path, &$crontab) {
        $dp = opendir($path);

        $comp_cron_flag = strpos($path, OSC_COMP_PATH) !== false;

        while (($file = readdir($dp)) !== false) {
            if ($file == '.' || $file == '..') {
                continue;
            }

            $file_path = $path . '/' . $file;

            if (is_dir($file_path)) {
                $this->_scanAndMakeCrontab($file_path, $crontab);
                continue;
            }

            if (!preg_match('/^(.+)\.php$/i', $file_path, $matches)) {
                continue;
            }

            if ($comp_cron_flag) {
                $matches[1] = str_replace(OSC_COMP_PATH . '/', '', $matches[1]);
                $matches[1] = explode('/', $matches[1]);
                unset($matches[1][0]);
                unset($matches[1][2]);
                $matches[1] = implode('_', $matches[1]);
                $matches[1] = preg_replace('/^([^_]+)_/', '\\1/', $matches[1]);
            } else {
                $matches[1] = str_replace(OSC_CORE_PATH . '/cron/cron/', '', $matches[1]);
                $matches[1] = str_replace('/', '_', $matches[1]);
            }

            $crontab = array_merge($crontab, OSC::cron($matches[1])->makeCrontab());
        }

        closedir($dp);
    }

    public function actionMakeCrontab() {
        $crontab = array();

        /* @var $module OSC_ModuleInfo */
        foreach (OSC::getModuleInfo() as $module) {
            $cron_dir = $module->getCodePath() . '/cron';

            if (file_exists($cron_dir)) {
                $this->_scanAndMakeCrontab($cron_dir, $crontab);
            }
        }

        $this->_scanAndMakeCrontab(OSC_CORE_PATH . '/cron/cron', $crontab);

        $crontab_file_path = $this->_request->get('crontab_file');

        if (!$crontab_file_path) {
            echo implode("\n", $crontab);
            die;
        }

        if (file_exists($crontab_file_path)) {
            $old_crontab = file_get_contents($crontab_file_path);

            $old_crontab = explode("\n", $old_crontab);

            $found_flag = false;

            foreach ($old_crontab as $idx => $line) {
                if (strpos($line, '#' . OSC_SITE_KEY . ' AUTOMAKE CRON - START') !== false) {
                    $found_flag = true;
                }

                if ($found_flag) {
                    unset($old_crontab[$idx]);
                }

                if (strpos($line, '#' . OSC_SITE_KEY . ' AUTOMAKE CRON - END') !== false) {
                    $found_flag = false;
                }
            }
        } else {
            $old_crontab = array();
        }

        $old_crontab[] = '#' . OSC_SITE_KEY . ' AUTOMAKE CRON - START';

        foreach ($crontab as $cron) {
            $old_crontab[] = $cron;
        }

        $old_crontab[] = '#' . OSC_SITE_KEY . ' AUTOMAKE CRON - END';

        OSC::writeToFile($crontab_file_path, implode("\n", $old_crontab));
    }

    public function actionHtml() {
        OSC::core('observer')->addObserver('shutdown', array($this, 'actionProcess'), 1);

        @header("Content-Type: image/gif");
        echo base64_decode("R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==");
        die;
    }

    public function getSystemProcessId() {
        return 'P' . OSC::getSystemProcessId() . ($this->_request->get('uniqid') ? (' | ' . $this->_request->get('uniqid')) : '');
    }

    public function actionProcess() {
        set_time_limit(0);

        echo date("F j, Y, g:i:s A") . ":\n==================================================================================================================================\n";

        $limit = intval($this->_request->get('limit'));

        if ($limit < 1) {
            $limit = 1;
        } else if ($limit > 1000) {
            $limit = 1000;
        }

        $cron_name = trim($this->_request->get('cron_name'));

        /* @var $DB OSC_Database */
        $DB = OSC::core('database');

        // $flag_file = OSC_VAR_PATH . '/.cron_flag';

        // if (!file_exists($flag_file)) {
        //     file_put_contents($flag_file, 1);

        //     chown($flag_file, OSC_FS_USERNAME);
        //     chgrp($flag_file, OSC_FS_USERNAME);
        //     chmod($flag_file, 0644);
        // }

        // if (filemtime($flag_file) < time() - (60 * 60)) {
        //     try {
        //         $DB->query("UPDATE `" . $DB->getTableName(OSC_Cron::TBL_QUEUE_NAME) . "` SET `error_flag` = 0, `error_message` = '', `requeue_counter` = (`requeue_counter` + 1), `locked_key` = '', `locked_timestamp` = 0 WHERE `scheduler_flag` = 0 AND `error_flag` = 1 AND (`requeue_limit` < 0 OR `requeue_counter` < `requeue_limit`)", null, 'requeue_cron');
        //         $DB->delete(OSC_Cron::TBL_QUEUE_NAME, "`scheduler_flag` = 0 AND `error_flag` = 1 AND `requeue_limit` >= 0 AND `requeue_counter` >= `requeue_limit` AND `locked_timestamp` < " . (time() - 60 * 60 * 24 * 10), null, 'clean_error_queue');
        //     } catch (Exception $ex) {

        //     }

        //     touch($flag_file);
        // }

        $lock_condition = array(
            'condition' => '`running_timestamp` <= ' . time() . ' AND `locked_timestamp` = 0 AND cron_name IN (\'' . implode("','", $this->_CRON_LIST) . '\')',
            'params' => array()
        );

        if ($cron_name) {
            $lock_condition['condition'] .= ' AND cron_name = :cron_name';
            $lock_condition['params']['cron_name'] = $cron_name;
        } else {
            $type = $this->_request->get('type') == 'scheduler' ? 'scheduler' : 'queue';
            $lock_condition['condition'] .= ' AND scheduler_flag = ' . ($type == 'scheduler' ? 1 : 0);
        }

        while ($limit > 0) {
            $limit --;

            $locked_key = OSC::makeUniqid(false, true);

            try {
                if ($DB->update(OSC_Cron::TBL_QUEUE_NAME, array('locked_key' => $locked_key, 'locked_timestamp' => time(), 'system_process_id' => $this->getSystemProcessId()), $lock_condition, 1) < 1) {
                    echo "NO CRON\n\n\n\n\n\n";
                    break;
                }
            } catch (Exception $ex) {
                echo "LOCK CRON ERROR: " . $ex->getMessage() . "\n\n\n\n\n\n";
                break;
            }

            $this->_processCron($locked_key);
        }
    }

    public function actionTrigger() {
        if (static::TRIGGER_CLI) {
            exec('php-cgi -f ' . OSC_SITE_PATH . '/index.php __request_path=cron/callback/directProcess queue_id=' . intval($this->_request->get('queue_id')) . ' __SERVER__=' . OSC::$domain . ' uniqid="' . OSC::randKey() . '-' . date('d.m.Y-H.i.s') . '" > /dev/null 2>&1 &');
        } else {
            $this->forward('directProcess');
        }
    }

    public function actionDirectProcess() {
        set_time_limit(0);

        echo date("F j, Y, g:i:s A") . ":\n==================================================================================================================================\n";

        $queue_id = intval($this->_request->get('queue_id'));

        if ($queue_id < 1) {
            echo "ERROR: QUEUE_ID cần lớn hơn 0";
            return;
        }

        $locked_key = OSC::makeUniqid(false, true);

        try {
            if (OSC::core('database')->update(OSC_Cron::TBL_QUEUE_NAME, array('locked_key' => $locked_key, 'locked_timestamp' => time(), 'system_process_id' => $this->getSystemProcessId()), '`queue_id` = ' . $queue_id . ' AND `locked_timestamp` = 0 AND cron_name IN (\'' . implode("','", $this->_CRON_LIST) . '\')', 1) < 1) {
                echo "ERROR: NO QUEUE\n\n\n\n\n\n";
                return;
            }
        } catch (Exception $ex) {
            echo "ERROR: LOCK CRON ERROR - " . $ex->getMessage() . "\n\n\n\n\n\n";
            return;
        }

        $this->_processCron($locked_key);
    }

    protected function _processCron($locked_key) {
        OSC::setInHeavyTaskFlag(true);

        /* @var $DB OSC_Database */
        $DB = OSC::core('database');

        $DB->select('*', OSC_Cron::TBL_QUEUE_NAME, array('condition' => '`locked_key` = :locked_key AND cron_name IN (\'' . implode("','", $this->_CRON_LIST) . '\')', 'params' => array('locked_key' => $locked_key)), null, 1);

        if ($DB->rowCount() < 1) {
            echo "CANNOT GET QUEUE BY LOCKED KEY\n";
            return;
        }

        $queue_item = $DB->fetchArray();

        print_r($queue_item);

        echo "\n";

        $cron = null;

        try {
            $cron = OSC::cron($queue_item['cron_name']);

            $this->_writeLog($queue_item, 'BEGIN');

            $process_return_flag = $cron->process(OSC::decode($queue_item['queue_data'], true), $queue_item['added_timestamp']);

            $this->_writeLog($queue_item, 'END');

            $this->_writeLog($queue_item, $cron->getLogData());

            echo "\nDONE CRON";

            if ($queue_item['scheduler_flag'] == 1) {
                $DB->update(OSC_Cron::TBL_QUEUE_NAME, array(
                    'running_timestamp' => OSC_Cron::getSchedulerNextRun($queue_item['scheduler_timer']),
                    'locked_key' => '',
                    'locked_timestamp' => 0,
                    'error_flag' => 0,
                    'error_message' => '',
                    'system_process_id' => null
                ), array('condition' => '`queue_id` = ' . $queue_item['queue_id']), 1);
            } else if ($process_return_flag === false) {
                $queue_data = OSC::decode($queue_item['queue_data']);
                $DB->update(OSC_Cron::TBL_QUEUE_NAME, array(
                    'running_timestamp' => time() + intval($queue_data['running_time'] ?? 60),
                    'locked_key' => '',
                    'locked_timestamp' => 0,
                    'error_flag' => 0,
                    'error_message' => '',
                    'system_process_id' => null
                ), array('condition' => '`queue_id` = ' . $queue_item['queue_id']), 1);
            } else if ($process_return_flag && is_string($process_return_flag)) {
                $DB->update(OSC_Cron::TBL_QUEUE_NAME, array(
                    'running_timestamp' => time() + 60,
                    'locked_key' => '',
                    'locked_timestamp' => 0,
                    'error_flag' => 0,
                    'error_message' => $process_return_flag,
                    'system_process_id' => null
                ), array('condition' => '`queue_id` = ' . $queue_item['queue_id']), 1);
            } else {
                $DB->delete(OSC_Cron::TBL_QUEUE_NAME, array('condition' => '`queue_id` = ' . $queue_item['queue_id']), 1);
            }
        } catch (Exception $ex) {
            $this->_writeLog($queue_item, 'END_WITH_ERR: ' . $ex->getMessage());

            echo "\nERROR AND BREAK: " . $ex->getMessage();

            $log_data = $cron ? $cron->getLogData() : array();
            $log_data[] = $ex->getMessage();

            $this->_writeLog($queue_item, $log_data);

            try {
                $DB->update(OSC_Cron::TBL_QUEUE_NAME, array('error_flag' => 1, 'error_message' => $ex->getMessage()), array('condition' => '`queue_id` = ' . $queue_item['queue_id']), 1);
            } catch (Exception $update_ex) {
                echo "\nUPDATE ERROR FLAG FAILED: " . $update_ex->getMessage();
            }
        }

        echo "\n\n\n\n\n\n";
    }

    protected function _writeLog($queue_item, $log_data) {
        OSC::core('database')->insert(OSC_Cron::TBL_LOG_NAME, array(
            'queue_id' => $queue_item['queue_id'],
            'queue_ukey' => $queue_item['ukey'],
            'system_process_id' => $this->getSystemProcessId(),
            'cron_name' => $queue_item['cron_name'],
            'queue_data' => in_array($log_data, ['BEGIN', 'END'], true) ? '[]' : OSC::encode($queue_item['queue_data']),
            'queue_locked_key' => $queue_item['locked_key'],
            'queue_locked_timestamp' => $queue_item['locked_timestamp'],
            'log_data' => OSC::encode($log_data),
            'added_timestamp' => time()
        ), 'insert_cron_log');
    }

}
